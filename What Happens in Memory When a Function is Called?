DSA-007D

### ðŸ§  1-Line Logic:

When a function is called, Java creates a **new memory block** (stack frame) for it, and once it finishes, that memory is removed.

---

### ðŸ”„ Step-by-Step Flow:

1ï¸âƒ£ **Program Starts** â†’ `main()` method runs

2ï¸âƒ£ Inside `main()`, a function is called

3ï¸âƒ£ A **new memory block (stack frame)** is created for that function

4ï¸âƒ£ Parameters receive **copies** of argument values

5ï¸âƒ£ Function runs its code and returns a value

6ï¸âƒ£ Memory block is **deleted** once function ends

7ï¸âƒ£ Control goes back to `main()` or calling point

---

### ðŸ“¦ Memory Analogy:

> Think of memory like a stack of plates ðŸ½ï¸
> 
> 
> Each time a function is called, a new plate is added (stack frame)
> 
> When function ends, the plate is removed (popped)
> 

---

### ðŸ“Œ Code Example:

```java
public class Main {

    static int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int x = 10;
        int y = 20;
        int result = add(x, y);
        System.out.println(result);
    }
}
```

---

### ðŸ“Š Memory View:

```java
Call Stack:
--------------
|  add()     | â† contains a=10, b=20
--------------
|  main()    | â† contains x=10, y=20
--------------
```

- When `add(10, 20)` is called â†’ memory created for `a` and `b`
- After return â†’ `add()` memory is cleared
- Only `main()` continues

---

### â— Important Note:

âœ… Java passes values using **"Call by Value"**

â›” That means **original variables are not modified** inside the function

---

### ðŸ’¡ Tip to Remember:

> "Each function gets its own temporary memory space, and it dies after returning."
>
