Big O Notation (Algorithm Analysis) ‚è±Ô∏è
üß† Logic:Big O Notation is a mathematical notation used to describe the efficiency of an algorithm in terms of time or space complexity. It describes the worst-case scenario (upper bound) for how the running time grows as the size of the input ($\mathbf{n}$) increases.It is crucial because it allows programmers to compare algorithms and choose the most efficient one, independent of the hardware being used. We usually ignore constants and lower-order terms.üìå Example:Java// O(1): Constant Time (Fastest)
int element = array[5]; 

// O(n): Linear Time (Scales directly with input size)
for (int i=0; i<n; i++) { /* operation */ }

// O(n^2): Quadratic Time (Scales poorly with input size)
for (int i=0; i<n; i++) {
    for (int j=0; j<n; j++) { /* operation */ }
}
üßÆ Common Time Complexities:NotationNameGrowth Rate (as n increases)Example$\mathbf{O(1)}$ConstantFlat (Fastest)Accessing Array Index$\mathbf{O(\log n)}$LogarithmicVery Slow IncreaseBinary Search, BST Operations$\mathbf{O(n)}$LinearDirect IncreaseLinear Search, Traversing a List$\mathbf{O(n \log n)}$Log-linearModerate IncreaseEfficient Sorting (Merge Sort, Heap Sort)$\mathbf{O(n^2)}$QuadraticFast/Exponential IncreaseInefficient Sorting (Bubble Sort, Selection Sort)üßæ Notebook Points:Javaüìò Big O Notation:
‚Üí Describes Algorithm Efficiency (Time/Space)
‚Üí Focuses on Worst-Case Scenario (Upper Bound)
‚Üí Ignores constants and low-order terms

üî¢ Goal: Compare algorithms objectively (e.g., O(n) is better than O(n^2))
‚úÖ Summary Table:üèóÔ∏è Topicüí° Core Conceptüõ†Ô∏è Typical ComplexityHeapPriority-based Binary TreeO($\log n$) for Insert/DeleteBig O NotationAlgorithm Time/Space EfficiencyVaries (O(1), O($\log n$), O(n), etc.)
