DSA-0261. Greedy Algorithms (Local Optimization) üí∞üß† Logic: A Greedy Algorithm is a simple, intuitive algorithmic paradigm that makes the $\mathbf{locally~optimal~choice}$ at each stage with the hope of finding a $\mathbf{globally~optimal~solution}$. At every step, the algorithm chooses the best option available at that moment, without regard for future consequences.Greedy algorithms are usually easier to implement and often faster than other approaches like Dynamic Programming. However, the greedy approach does not always guarantee the globally optimal solution. You must formally prove that the greedy choice leads to the global optimum for the specific problem.A classic example is the Coin Change Problem where, for standard currencies, always picking the largest coin possible works (a greedy choice).üìå Example:Problem: Activity Selection
Goal: Select the maximum number of non-overlapping activities.
Greedy Choice: Always select the activity that finishes earliest among the remaining ones. 
ü§π‚Äç‚ôÄÔ∏è Java Code (Activity Selection - Greedy Approach): Javaimport java.util.Arrays;
import java.util.Comparator;

public class GreedyActivitySelection {
    public static void selectActivities(int[] start, int[] finish) {
        int n = start.length;
        int[][] activities = new int[n][2];
        for (int i = 0; i < n; i++) {
            activities[i][0] = start[i];
            activities[i][1] = finish[i];
        }

        // Greedy Choice: Sort by finish time (the core of the algorithm)
        Arrays.sort(activities, Comparator.comparingInt(a -> a[1]));

        System.out.print("Selected Activities: " + activities[0][0] + "-" + activities[0][1] + " ");
        int lastFinishTime = activities[0][1];

        // Iterate through the remaining activities
        for (int i = 1; i < n; i++) {
            if (activities[i][0] >= lastFinishTime) { // Non-overlapping condition
                System.out.print(activities[i][0] + "-" + activities[i][1] + " ");
                lastFinishTime = activities[i][1];
            }
        }
    }

    public static void main(String[] args) {
        int[] start = {1, 3, 0, 5, 8, 5};
        int[] finish = {2, 4, 6, 7, 9, 9};
        selectActivities(start, finish); 
        // Output (Varies slightly based on tie-breaking): Selected Activities: 1-2 3-4 5-7 8-9 
    }
}
üßæ Notebook Points:Javaüìò Greedy Algorithms:
‚Üí Makes the best LOCAL choice at each step
‚Üí Goal: Achieve GLOBAL optimum
‚Üí Fast and simple to implement

üî¢ Use Cases: Activity Selection, Fractional Knapsack, Prim's/Kruskal's MST
